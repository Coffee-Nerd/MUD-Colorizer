<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- If you're reading this, you might like this tool, but it would be NICE if you could credit me somehow.
         Demon, Despair, Asmodeus, or Jeff. https://www.github.com/coffee-nerd/
         Please leave this line in the code. Preferably we can collaborate and you can just make a pull request. -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MUD Colorizer</title>
    <style>
      body {
        background-color: black;
        color: white;
        /* Default to Fira Code */
        font-family: "Fira Code", monospace;
        padding: 20px;
      }
      #output {
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        margin-top: 20px;
        border: 1px solid #444;
        padding: 10px;
        background-color: #111;
      }
      #controls {
        margin-bottom: 20px;
      }
      label {
        color: white;
        font-size: 1rem;
        margin-right: 10px;
      }
      textarea {
        width: 100%;
        height: 150px;
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 10px;
        font-family: inherit;
        resize: vertical;
      }
      select {
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 5px;
        font-family: inherit;
        margin-right: 10px;
      }
      .preview-box {
        display: inline-block;
        vertical-align: middle;
        width: 100px;
        height: 20px;
        margin-left: 10px;
        border: 1px solid #444;
        background: black;
      }
      .mode-selector {
        margin-bottom: 20px;
      }
      .mode-selector input {
        margin-right: 5px;
      }
      .disabled {
        opacity: 0.5;
        pointer-events: none;
      }
      /* Custom Gradient Inputs */
      .custom-gradient-input {
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 5px;
        font-family: inherit;
      }
      /* Toggle buttons styling */
      #toggleCustomGradientButton,
      #toggleManageCustomGradients {
        background-color: #111;
        color: white;
        border: 1px solid #444;
        padding: 5px 10px;
        font-family: inherit;
        cursor: pointer;
        margin-bottom: 10px;
      }
      /* Shake animation */
      @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        50% { transform: translateX(5px); }
        75% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
      }
      .shake {
        animation: shake 0.3s;
      }
      .invalid {
        border: 2px solid red !important;
      }
      /* Manage Custom Gradients section */
      #manageCustomGradients {
        display: none;
        border: 1px solid #444;
        padding: 10px;
        margin-top: 10px;
      }
      #manageCustomGradients h3 {
        margin-top: 0;
      }
      /* Inline help text */
      .help-text {
        font-size: 0.8rem;
        color: #888;
      }
      /* Styling for each editable custom gradient item */
      .custom-gradient-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        border-bottom: 1px solid #444;
        padding-bottom: 5px;
      }
      .custom-gradient-item input[type="text"] {
        margin-right: 10px;
      }
      .custom-gradient-preview {
        width: 80px;
        height: 20px;
        border: 1px solid #444;
        margin-right: 10px;
      }
      /* Brightness adjustment controls */
      .brightness-controls {
        display: flex;
        align-items: center;
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #444;
        background-color: #1a1a1a;
      }
      .brightness-slider {
        width: 200px;
        margin: 0 10px;
      }
      .brightness-value {
        width: 50px;
        text-align: center;
        color: #888;
      }
      /* Character counter styling */
      #charCounter {
        float: right;
        color: #888;
        font-size: 0.9rem;
        margin-top: 5px;
      }
      #charCounter.over-limit {
        color: #ff0000;
      }
      /* Output container to hold both the output and counter */
      .output-container {
        position: relative;
      }
      /* Line character count styling */
      .line-char-count {
        color: #666;
        font-size: 0.8rem;
        display: inline-block;
        margin-left: 10px;
        user-select: none;
        white-space: nowrap;
        position: absolute;
        right: 10px;
      }
      .line-char-count.over-limit {
        color: #ff0000;
      }
      /* Copy button styling */
      .copy-container {
        position: relative;
        display: inline-block;
        width: 100%;
      }
      .copy-button {
        position: absolute;
        top: 8px;
        right: 8px;
        background-color: #333;
        color: white;
        border: 1px solid #555;
        padding: 6px 12px;
        font-family: inherit;
        font-size: 0.85rem;
        cursor: pointer;
        border-radius: 4px;
        z-index: 10;
        transition: all 0.2s ease;
      }
      .copy-button:hover {
        background-color: #444;
        border-color: #666;
      }
      .copy-button:active {
        background-color: #222;
        transform: translateY(1px);
      }
      .copy-button.copied {
        background-color: #0a5d0a;
        border-color: #0f8f0f;
      }
    </style>
  </head>
  <body>
    <h1 style="color: white">MUD Colorizer</h1>
    <div id="controls">
      <!-- Mode Selection -->
      <div class="mode-selector">
        <label>Select Mode:</label>
        <input type="radio" id="editMode" name="mode" value="edit" checked />
        <label for="editMode">Edit Mode</label>
        <input
          type="radio"
          id="viewMode"
          name="mode"
          value="view"
          style="margin-left: 20px"
        />
        <label for="viewMode">Viewer Mode</label>
      </div>

      <!-- Font Selection -->
      <div>
        <label for="fontSelector">Select Font:</label>
        <select id="fontSelector">
          <option value="'Fira Code', monospace" selected>Fira Code</option>
          <option value="'Courier New', monospace">Courier New</option>
          <option value="'Hack', monospace">Hack</option>
          <option value="'JetBrains Mono', monospace">JetBrains Mono</option>
          <option value="'Roboto Mono', monospace">Roboto Mono</option>
          <option value="'Source Code Pro', monospace">Source Code Pro</option>
          <option value="'Ubuntu Mono', monospace">Ubuntu Mono</option>
          <option value="'Monaco', monospace">Monaco</option>
          <option value="'Consolas', monospace">Consolas</option>
          <option value="'Anonymous Pro', monospace">Anonymous Pro</option>
        </select>
      </div>
      <br />

      <!-- Code Format Selection -->
      <div>
        <label for="formatSelector">Color Codes:</label>
        <select id="formatSelector">
          <option value="@x">Xterm: @xNNN</option>
          <option value="{x">Xterm: {xNNN</option>
          <option value="$x">Xterm: $xNNN</option>
          <option value="@[F">Xterm F-colors: @[FNNN]</option>
          <option value="^[F">Xterm F-colors: ^[FNNN]</option>
          <option value="\t">Xterm Builder F-colors: \t[FNNN]</option>
          <option value="&amp;">Xterm: &amp;NNN</option>
          <option value="ansi-shell">ANSI Shell: \\033[...m (for echo -e)</option>
          <option value="ansi-rust">ANSI Rust: \\x1B[...m</option>
          <option value="ansi-lua">ANSI Lua: \\27[...m</option>
          <option value="ansi-c">ANSI C/Java: \\033[...m</option>
        </select>
      </div>
      <br />

      <!-- Text Input -->
      <label for="textInput">Paste Your Text:</label><br />
      <textarea id="textInput" placeholder="Paste your text here..."></textarea>
      <br /><br />

      <!-- Gradient Selection -->
      <div id="gradientControls">
        <div>
          <label for="gradientSelect">Select Gradient:</label>
          <select id="gradientSelect"></select>
          <span class="preview-box" id="gradientPreview"></span>
          &nbsp;&nbsp;
          <input type="checkbox" id="invertGradient" />
          <label for="invertGradient">Invert</label>
        </div>
        <br />

        <!-- Pattern Selection -->
        <div>
          <label for="patternSelect">Pattern:</label>
          <select id="patternSelect">
            <option value="original">Original</option>
            <option value="distributed">Distributed</option>
            <option value="symmetrical">Symmetrical</option>
          </select>
          &nbsp;&nbsp;&nbsp;&nbsp;
          <button id="instantLighterButton" style="background-color: #111; color: white; border: 1px solid #444; padding: 5px 10px; font-family: inherit; cursor: pointer;" title="Make colors 5% lighter. Note: For xterm colors, adjustments may not be perfectly reversible due to palette limitations. Truecolor ($X) format preserves full precision.">Lighter</button>
          &nbsp;
          <button id="instantDarkerButton" style="background-color: #111; color: white; border: 1px solid #444; padding: 5px 10px; font-family: inherit; cursor: pointer;" title="Make colors 5% darker. Note: For xterm colors, adjustments may not be perfectly reversible due to palette limitations. Truecolor ($X) format preserves full precision.">Darker</button>
        </div>
        <br />

        <!-- Format Controls -->
        <div>
          <label for="wrapLimit">Format at character limit:</label>
          <input
            type="number"
            id="wrapLimit"
            min="20"
            max="200"
            value="80"
            style="width: 60px; background-color: #111; color: white; border: 1px solid #444; padding: 5px; font-family: inherit;"
          />
          &nbsp;&nbsp;
          <button
            id="formatButton"
            style="background-color: #111; color: white; border: 1px solid #444; padding: 5px 10px; font-family: inherit; cursor: pointer;"
          >
            Format
          </button>
        </div>
        <br />

        <!-- Toggle button for Custom Gradient -->
        <div>
          <input type="button" id="toggleCustomGradientButton" value="Create custom gradient" />
          &nbsp;&nbsp;
          <input type="button" id="randomGradientButton" value="Generate random truecolor gradient" style="background-color: #111; color: white; border: 1px solid #444; padding: 5px 10px; font-family: inherit; cursor: pointer;" />
          &nbsp;&nbsp;
          <input type="button" id="saveRandomGradientButton" value="Save generated gradient" style="background-color: #111; color: white; border: 1px solid #444; padding: 5px 10px; font-family: inherit; cursor: pointer; display: none;" />
        </div>
        <br />

        <!-- Add New Gradients (hidden by default) -->
        <div id="addGradient" style="display: none;">
          <div>
            <label>Add New Gradient:</label>
            <label for="newGradientName">Name</label>
            <input
              type="text"
              id="newGradientName"
              placeholder="My Gradient"
              required
              pattern="^[\w\s]+$"
              title="Enter a name (letters, numbers, and spaces only)"
              class="custom-gradient-input"
            />
            <small class="help-text">Allowed: letters, numbers, spaces</small>
            &nbsp;|&nbsp;
            <label for="newGradientCodes">Color Codes</label>
            <input
              type="text"
              id="newGradientCodes"
              placeholder="120 16 220 161"
              required
              pattern="^(?:[0-9]{1,3}(?:\s+[0-9]{1,3})*)$"
              title="Enter space-separated numbers between 0 and 255"
              class="custom-gradient-input"
            />
            <small class="help-text">E.g.: 54 55 56 57</small>
            <span class="preview-box" id="customGradientPreview"></span>
            <input type="button" id="newGradientProcess" value="Add" />
          </div>
        </div>
        <br />

        <!-- Toggle button for managing custom gradients -->
        <div>
          <input type="button" id="toggleManageCustomGradients" value="Manage custom gradients" />
        </div>
        <br />

        <!-- Manage Custom Gradients Section -->
        <div id="manageCustomGradients">
          <h3>Custom Gradients</h3>
          <div id="customGradientsList"></div>
        </div>
        <br />

        <!-- Pattern Selection - Removed from here -->
      </div>
    </div>

    <div class="output-container">
      <div id="output"></div>
      <div id="charCounter">Character count per line →</div>
    </div>

    <div style="margin-top: 20px;">
      <label for="copyableOutput">Copyable Text with Color Codes:</label>
      <span id="ansiHelp" style="display: none; color: #888; font-size: 0.85rem; margin-left: 10px;">
        (Use with echo -e or printf in terminal)
      </span>
      <br />
      <div class="copy-container">
        <textarea 
          id="copyableOutput" 
          style="width: 100%; height: 150px; background-color: #111; color: white; border: 1px solid #444; padding: 10px; font-family: inherit; resize: vertical;" 
          readonly
          placeholder="Color-coded text will appear here..."
        ></textarea>
        <button id="copyButton" class="copy-button" title="Copy to clipboard">Copy</button>
      </div>
    </div>

    <script>
      // Standard 16 color mapping
      const standardColorMap = {
        k: "#000000", // Black
        K: "#555555", // Bright Black (Gray)
        r: "#800000", // Dark Red
        R: "#ff0000", // Bright Red
        g: "#008000", // Dark Green
        G: "#00ff00", // Bright Green
        y: "#808000", // Dark Yellow
        Y: "#ffff00", // Bright Yellow
        b: "#000080", // Dark Blue
        B: "#0000ff", // Bright Blue
        m: "#800080", // Dark Magenta
        M: "#ff00ff", // Bright Magenta
        c: "#008080", // Dark Cyan
        C: "#00ffff", // Bright Cyan
        w: "#c0c0c0", // Dark White (Silver)
        W: "#ffffff", // Bright White
        D: "#333333", // Blackish
      };

      // Map standard color letters to an xterm index
      const standardColorToIndex = {
        k: 0,
        K: 8,
        r: 1,
        R: 9,
        g: 2,
        G: 10,
        y: 3,
        Y: 11,
        b: 4,
        B: 12,
        m: 5,
        M: 13,
        c: 6,
        C: 14,
        w: 7,
        W: 15,
        D: 8,
      };

      // Convert an Xterm color index (0-255) into an RGB hex color
      function xtermToRgbHex(colorIndex) {
        if (colorIndex < 16) {
          const standardColors = [
            "#000000",
            "#800000",
            "#008000",
            "#808000",
            "#000080",
            "#800080",
            "#008080",
            "#c0c0c0",
            "#808080",
            "#ff0000",
            "#00ff00",
            "#ffff00",
            "#0000ff",
            "#ff00ff",
            "#00ffff",
            "#ffffff",
          ];
          return standardColors[colorIndex];
        } else if (colorIndex >= 16 && colorIndex <= 231) {
          const base = colorIndex - 16;
          const r = (Math.floor(base / 36) % 6) * 51;
          const g = (Math.floor(base / 6) % 6) * 51;
          const b = (base % 6) * 51;
          return `rgb(${r},${g},${b})`;
        } else if (colorIndex >= 232 && colorIndex <= 255) {
          const gray = Math.round((colorIndex - 232) * 10 + 8);
          return `rgb(${gray},${gray},${gray})`;
        } else {
          return "#ffffff";
        }
      }
     // So what the hell even are these F colors? (Heh)
     // "F-colors" are essentially a shorthand notation for specifying colors in the 6×6×6 color cube used by xterm's 256-color palette. 
     //  Instead of using a direct numeric index (like @x123), an F-color (e.g. @[F123] or ^[F123]) breaks the color into three digits—
     //  each representing a value (0–5) for red, green, and blue respectively. The conversion function then maps these digits into the 
     //  appropriate xterm color index (from 16 to 231).
     //  In short, while they ultimately refer to colors in the xterm palette, the notation is different. They may appear to differ because:
     //  Xterm codes typically use a numeric index or direct hex representation.
     //  F-colors encode the red, green, and blue components as three digits, which are then converted into the xterm index.
     //  This extra layer of abstraction can make them seem different even though they're designed to represent the same range of colors.
      function fToRgbHex(fCode) {
        // fCode example: "F012" => r=0, g=1, b=2
        const codeStr = fCode.slice(1);
        const r = parseInt(codeStr.charAt(0), 10);
        const g = parseInt(codeStr.charAt(1), 10);
        const b = parseInt(codeStr.charAt(2), 10);
        const colorIndex = 16 + 36 * r + 6 * g + b;
        return xtermToRgbHex(colorIndex);
      }

      function renderXterm(text) {
        let output = "";
        let currentColor = "#ffffff";
        let lineCharCount = 0;
        let lines = [];
        let currentLine = "";

        // Extended regex to also match ANSI escape sequences (all formats: \x1b, \u001b, \\033, \\x1B, \\27)
        const renderRegex = /((?:\x1b|\u001b|\\033|\\x1B|\\27)\[(?:0|3[0-7]|9[0-7]|38;5;\d{1,3}|38;2;\d{1,3};\d{1,3};\d{1,3})m|\$X[0-9a-fA-F]{6}|\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rRgGyYbBmMcCwWdD](?:\d{3})?|@[rRgGyYbBmMcCwWdD](?:\d{3})?|\&[rRgGyYbBmMcCwWdD](?:\d{3})?|\{[rRgGyYbBmMcCwWdD](?:\d{3})?|\{\d{3}|\&\d{3})|([\s\S])/g;

        text.replace(renderRegex, (match, colorCode, textContent) => {
          if (colorCode) {
            if (colorCode.startsWith("\x1b[") || colorCode.startsWith("\u001b[") || colorCode.includes("\\033[") || colorCode.includes("\\x1B[") || colorCode.includes("\\27[")) {
              // Handle ANSI escape codes
              if (colorCode === "\x1b[0m" || colorCode === "\u001b[0m" || colorCode === "\\033[0m" || colorCode === "\\x1B[0m" || colorCode === "\\27[0m") {
                currentColor = "#ffffff"; // Reset
              } else if (colorCode.match(/(?:\x1b|\u001b|\\033|\\x1B|\\27)\[3[0-7]m/)) {
                // Standard colors (30-37)
                const colorNum = parseInt(colorCode.match(/[0-7]/)[0]);
                currentColor = xtermToRgbHex(colorNum);
              } else if (colorCode.match(/(?:\x1b|\u001b|\\033|\\x1B|\\27)\[9[0-7]m/)) {
                // Bright colors (90-97)
                const colorNum = parseInt(colorCode.match(/[0-7]/)[0]) + 8;
                currentColor = xtermToRgbHex(colorNum);
              } else if (colorCode.match(/(?:\x1b|\u001b|\\033|\\x1B|\\27)\[38;5;(\d+)m/)) {
                // 256 color
                const matches = colorCode.match(/(?:\x1b|\u001b|\\033|\\x1B|\\27)\[38;5;(\d+)m/);
                const colorNum = parseInt(matches[1]);
                currentColor = xtermToRgbHex(colorNum);
              } else if (colorCode.match(/(?:\x1b|\u001b|\\033|\\x1B|\\27)\[38;2;(\d+);(\d+);(\d+)m/)) {
                // True color
                const matches = colorCode.match(/(?:\x1b|\u001b|\\033|\\x1B|\\27)\[38;2;(\d+);(\d+);(\d+)m/);
                const r = parseInt(matches[1]);
                const g = parseInt(matches[2]);
                const b = parseInt(matches[3]);
                currentColor = `rgb(${r},${g},${b})`;
              }
            } else if (colorCode.startsWith("$X") && colorCode.length === 8) {
              // Handle $X truecolor format
              const hex = colorCode.slice(2);
              currentColor = `#${hex}`;
            } else if (
              (colorCode.startsWith("$x") ||
                colorCode.startsWith("@x") ||
                colorCode.startsWith("{x")) &&
              colorCode.length === 5
            ) {
              const idx = parseInt(colorCode.slice(2), 10);
              currentColor = xtermToRgbHex(idx);
            } else if (colorCode.startsWith("@[") && colorCode.endsWith("]")) {
              const inside = colorCode.slice(2, -1);
              currentColor = fToRgbHex(inside);
            } else if (colorCode.startsWith("^[") && colorCode.endsWith("]")) {
              const inside = colorCode.slice(2, -1);
              currentColor = fToRgbHex(inside);
            } else if (
              colorCode.startsWith("\\t[") &&
              colorCode.endsWith("]")
            ) {
              const inside = colorCode.slice(3, -1);
              currentColor = fToRgbHex(inside);
            } else if (colorCode.startsWith("&")) {
              const m = colorCode.match(/^&([rRgGyYbBmMcCwWdD])(\d{3})?$/);
              if (m) {
                if (m[2]) {
                  const idx = parseInt(m[2], 10);
                  currentColor = xtermToRgbHex(idx);
                } else {
                  const c = m[1];
                  currentColor = standardColorMap[c] || "#ffffff";
                }
              } else if (/^&\d{3}$/.test(colorCode)) {
                const idx = parseInt(colorCode.slice(1), 10);
                currentColor = xtermToRgbHex(idx);
              }
            } else if (colorCode.startsWith("{")) {
              if (colorCode.startsWith("{x") && colorCode.length === 5) {
                const idx = parseInt(colorCode.slice(2), 10);
                currentColor = xtermToRgbHex(idx);
              } else {
                const m = colorCode.match(/^\{([rRgGyYbBmMcCwWdD])(\d{3})?$/);
                if (m) {
                  if (m[2]) {
                    const idx = parseInt(m[2], 10);
                    currentColor = xtermToRgbHex(idx);
                  } else {
                    const c = m[1];
                    currentColor = standardColorMap[c] || "#ffffff";
                  }
                } else if (/^\{\d{3}$/.test(colorCode)) {
                  const idx = parseInt(colorCode.slice(1), 10);
                  currentColor = xtermToRgbHex(idx);
                }
              }
            } else if (colorCode === "@n") {
              currentColor = "#ffffff";
            } else if (colorCode.match(/^\$[rRgGyYbBmMcCwWdD](?:\d{3})?$/)) {
              const c = colorCode.charAt(1);
              currentColor = standardColorMap[c] || "#ffffff";
            } else if (colorCode.match(/^@[rRgGyYbBmMcCwWdD](?:\d{3})?$/)) {
              const c = colorCode.charAt(1);
              currentColor = standardColorMap[c] || "#ffffff";
            }
          } else if (textContent) {
            if (textContent === "\n") {
              lines.push({ content: currentLine, count: lineCharCount });
              currentLine = "";
              lineCharCount = 0;
            } else {
              if (/\s/.test(textContent)) {
                currentLine += escapeHtml(textContent);
              } else {
                currentLine += `<span style="color: ${currentColor}">${escapeHtml(textContent)}</span>`;
              }
              lineCharCount++;
            }
          }
        });
        
        // Add the last line if it has content
        if (currentLine) {
          lines.push({ content: currentLine, count: lineCharCount });
        }
        
        // Build the output with line character counts
        lines.forEach(line => {
          output += `<div style="position: relative; padding-right: 40px;">${line.content}<span class="line-char-count">${line.count}</span></div>`;
        });
        
        return output;
      }

      function escapeHtml(text) {
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#039;",
        };
        return text.replace(/[&<>"']/g, function (m) {
          return map[m];
        });
      }

      // Helper functions for random gradient generation
      function randomRgbColor() {
        return {
          r: Math.floor(Math.random() * 256),
          g: Math.floor(Math.random() * 256),
          b: Math.floor(Math.random() * 256)
        };
      }

      function toHex(n) {
        return n.toString(16).padStart(2, '0');
      }

      // Brightness adjustment functions
      function adjustBrightness(rgb, factor, preservePrecision = false) {
        // factor is -100 to 100
        // For truecolor, we want to avoid rounding errors
        if (preservePrecision) {
          // Use a reversible linear transformation
          // Use a fixed step size for better reversibility (13 units per 5%)
          const adjustment = factor > 0 ? 13 : -13;
          return {
            r: Math.max(0, Math.min(255, rgb.r + adjustment)),
            g: Math.max(0, Math.min(255, rgb.g + adjustment)),
            b: Math.max(0, Math.min(255, rgb.b + adjustment))
          };
        } else {
          // For xterm colors, use blending approach
          if (factor > 0) {
            // Lightening: blend with white
            const blend = factor / 100;
            return {
              r: Math.round(rgb.r + (255 - rgb.r) * blend),
              g: Math.round(rgb.g + (255 - rgb.g) * blend),
              b: Math.round(rgb.b + (255 - rgb.b) * blend)
            };
          } else {
            // Darkening: blend with black
            const blend = -factor / 100;
            return {
              r: Math.round(rgb.r * (1 - blend)),
              g: Math.round(rgb.g * (1 - blend)),
              b: Math.round(rgb.b * (1 - blend))
            };
          }
        }
      }

      function xtermToRgb(colorIndex) {
        if (colorIndex < 16) {
          const standardColors = [
            {r: 0, g: 0, b: 0},      // 0: black
            {r: 128, g: 0, b: 0},    // 1: dark red
            {r: 0, g: 128, b: 0},    // 2: dark green
            {r: 128, g: 128, b: 0},  // 3: dark yellow
            {r: 0, g: 0, b: 128},    // 4: dark blue
            {r: 128, g: 0, b: 128},  // 5: dark magenta
            {r: 0, g: 128, b: 128},  // 6: dark cyan
            {r: 192, g: 192, b: 192},// 7: silver
            {r: 128, g: 128, b: 128},// 8: gray
            {r: 255, g: 0, b: 0},    // 9: red
            {r: 0, g: 255, b: 0},    // 10: green
            {r: 255, g: 255, b: 0},  // 11: yellow
            {r: 0, g: 0, b: 255},    // 12: blue
            {r: 255, g: 0, b: 255},  // 13: magenta
            {r: 0, g: 255, b: 255},  // 14: cyan
            {r: 255, g: 255, b: 255} // 15: white
          ];
          return standardColors[colorIndex];
        } else if (colorIndex >= 16 && colorIndex <= 231) {
          const base = colorIndex - 16;
          const r = (Math.floor(base / 36) % 6) * 51;
          const g = (Math.floor(base / 6) % 6) * 51;
          const b = (base % 6) * 51;
          return {r, g, b};
        } else if (colorIndex >= 232 && colorIndex <= 255) {
          const gray = Math.round((colorIndex - 232) * 10 + 8);
          return {r: gray, g: gray, b: gray};
        } else {
          return {r: 255, g: 255, b: 255};
        }
      }

      function rgbToXterm(rgb) {
        // Find closest xterm color
        let minDistance = Infinity;
        let closestIndex = 0;
        
        // Check standard 16 colors
        for (let i = 0; i < 16; i++) {
          const xterm = xtermToRgb(i);
          const distance = Math.pow(rgb.r - xterm.r, 2) + 
                          Math.pow(rgb.g - xterm.g, 2) + 
                          Math.pow(rgb.b - xterm.b, 2);
          if (distance < minDistance) {
            minDistance = distance;
            closestIndex = i;
          }
        }
        
        // Check 6x6x6 color cube
        const xr = Math.round(rgb.r / 51);
        const xg = Math.round(rgb.g / 51);
        const xb = Math.round(rgb.b / 51);
        const cubeIndex = 16 + 36 * Math.min(5, xr) + 6 * Math.min(5, xg) + Math.min(5, xb);
        const cubeColor = xtermToRgb(cubeIndex);
        const cubeDistance = Math.pow(rgb.r - cubeColor.r, 2) + 
                            Math.pow(rgb.g - cubeColor.g, 2) + 
                            Math.pow(rgb.b - cubeColor.b, 2);
        if (cubeDistance < minDistance) {
          closestIndex = cubeIndex;
        }
        
        return closestIndex;
      }

      // Adjust xterm color within its own color space
      function adjustXtermColor(colorIndex, lighter) {
        // Standard 16 colors (0-15) - use predefined mappings
        if (colorIndex < 16) {
          const standardLighter = {
            0: 8,   // black -> gray
            1: 9,   // dark red -> bright red
            2: 10,  // dark green -> bright green
            3: 11,  // dark yellow -> bright yellow
            4: 12,  // dark blue -> bright blue
            5: 13,  // dark magenta -> bright magenta
            6: 14,  // dark cyan -> bright cyan
            7: 15,  // silver -> white
            8: 15,  // gray -> white
            9: 9,   // bright red (stay at max)
            10: 10, // bright green (stay at max)
            11: 11, // bright yellow (stay at max)
            12: 12, // bright blue (stay at max)
            13: 13, // bright magenta (stay at max)
            14: 14, // bright cyan (stay at max)
            15: 15  // white (stay at max)
          };
          const standardDarker = {
            0: 0,   // black (stay at min)
            1: 1,   // dark red (stay at min)
            2: 2,   // dark green (stay at min)
            3: 3,   // dark yellow (stay at min)
            4: 4,   // dark blue (stay at min)
            5: 5,   // dark magenta (stay at min)
            6: 6,   // dark cyan (stay at min)
            7: 8,   // silver -> gray
            8: 0,   // gray -> black
            9: 1,   // bright red -> dark red
            10: 2,  // bright green -> dark green
            11: 3,  // bright yellow -> dark yellow
            12: 4,  // bright blue -> dark blue
            13: 5,  // bright magenta -> dark magenta
            14: 6,  // bright cyan -> dark cyan
            15: 7   // white -> silver
          };
          return lighter ? standardLighter[colorIndex] : standardDarker[colorIndex];
        }
        
        // 6x6x6 color cube (16-231)
        if (colorIndex >= 16 && colorIndex <= 231) {
          const base = colorIndex - 16;
          let r = Math.floor(base / 36) % 6;
          let g = Math.floor(base / 6) % 6;
          let b = base % 6;
          
          if (lighter) {
            // Increase each component by 1 (max 5)
            r = Math.min(5, r + 1);
            g = Math.min(5, g + 1);
            b = Math.min(5, b + 1);
          } else {
            // Decrease each component by 1 (min 0)
            r = Math.max(0, r - 1);
            g = Math.max(0, g - 1);
            b = Math.max(0, b - 1);
          }
          
          return 16 + 36 * r + 6 * g + b;
        }
        
        // Grayscale ramp (232-255)
        if (colorIndex >= 232 && colorIndex <= 255) {
          if (lighter) {
            return Math.min(255, colorIndex + 1);
          } else {
            return Math.max(232, colorIndex - 1);
          }
        }
        
        return colorIndex; // fallback
      }

      function generateRandomTruecolorGradient(str) {
        let chars = Array.from(str);
        // count only non-whitespace characters for gradient steps
        let total = chars.filter(c => /\S/.test(c)).length;

        // Use two random colors for the gradient ends
        let startColor = randomRgbColor();
        let endColor = randomRgbColor();

        let out = '';
        let nonWhitespaceIdx = 0;
        let lastAppliedColorHex = null; // Track last applied truecolor hex

        for (let char of chars) {
          if (/\s/.test(char)) {
            out += char; // Add whitespace directly
          } else {
            // Calculate interpolation factor (t) based on non-whitespace character index
            let t = total > 1 ? nonWhitespaceIdx / (total - 1) : 0;

            // Interpolate RGB components
            let r = Math.round(startColor.r + (endColor.r - startColor.r) * t);
            let g = Math.round(startColor.g + (endColor.g - startColor.g) * t);
            let b = Math.round(startColor.b + (endColor.b - startColor.b) * t);

            // Always use $X format for random gradients (will be converted if needed)
            let hex = toHex(r) + toHex(g) + toHex(b);
            const colorCode = '$X' + hex;

            // Only apply color code if it's different from the last one
            if (colorCode !== lastAppliedColorHex) {
                 out += colorCode;
                 lastAppliedColorHex = colorCode;
            }

            out += char;
            nonWhitespaceIdx++;
          }
        }
        return out;
      }

      function wrapColorCode(colorIndex) {
        const format = document.getElementById("formatSelector").value;
        if (format === "@x") {
          return `@x${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "{x") {
          return `{x${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "$x") {
          return `$x${String(colorIndex).padStart(3, "0")}`;
        } else if (format === "&") {
          return `&${String(colorIndex).padStart(3, "0")}`;
        } else if (format.startsWith("ansi-")) {
          // ANSI escape codes - different formats for different languages
          let escapeSeq;
          if (format === "ansi-shell") {
            escapeSeq = "\\033";
          } else if (format === "ansi-rust") {
            escapeSeq = "\\x1B";
          } else if (format === "ansi-lua") {
            escapeSeq = "\\27";
          } else if (format === "ansi-c") {
            escapeSeq = "\\033";
          }
          
          if (colorIndex < 8) {
            // Standard colors (30-37)
            return `${escapeSeq}[3${colorIndex}m`;
          } else if (colorIndex < 16) {
            // Bright colors (90-97)
            return `${escapeSeq}[9${colorIndex - 8}m`;
          } else {
            // Extended 256 colors
            return `${escapeSeq}[38;5;${colorIndex}m`;
          }
        } else if (format === "@[F") {
          let fCode = "F000";
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          } else {
            const clamped = Math.min(Math.max(colorIndex, 16), 231);
            const base = clamped - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          }
          return `@[${fCode}]`;
        } else if (format === "^[F") {
          let fCode = "F000";
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          } else {
            const clamped = Math.min(Math.max(colorIndex, 16), 231);
            const base = clamped - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          }
          return `^[${fCode}]`;
        } else if (format === "\\t") {
          let fCode = "F000";
          if (colorIndex >= 16 && colorIndex <= 231) {
            const base = colorIndex - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          } else {
            const clamped = Math.min(Math.max(colorIndex, 16), 231);
            const base = clamped - 16;
            const r = Math.floor(base / 36) % 6;
            const g = Math.floor(base / 6) % 6;
            const b = base % 6;
            fCode = `F${r}${g}${b}`;
          }
          return `\\t[${fCode}]`;
        }
        return `@x${String(colorIndex).padStart(3, "0")}`;
      }

      function convertColorCodesToFormat(text, newFormat) {
        let converted = "";
        // Add ANSI reset when switching to ANSI format
        let needsReset = false;
        
        text.replace(regex, (match, colorCode, textContent) => {
          if (colorCode) {
            let colorIndex = null;
            if (
              (colorCode.startsWith("$x") ||
                colorCode.startsWith("@x") ||
                colorCode.startsWith("{x")) &&
              colorCode.length === 5
            ) {
              colorIndex = parseInt(colorCode.slice(2), 10);
            } else if (
              (colorCode.startsWith("@[F") && colorCode.endsWith("]")) ||
              (colorCode.startsWith("\\t[F") && colorCode.endsWith("]")) ||
              (colorCode.startsWith("^[F") && colorCode.endsWith("]"))
            ) {
              const inside = colorCode.includes("\\t")
                ? colorCode.slice(3, -1)
                : colorCode.slice(2, -1);
              const r = parseInt(inside.charAt(1), 10);
              const g = parseInt(inside.charAt(2), 10);
              const b = parseInt(inside.charAt(3), 10);
              colorIndex = 16 + 36 * r + 6 * g + b;
            } else if (colorCode === "@n") {
              colorIndex = 7;
            } else if (
              colorCode.match(/^\$[rRgGyYbBmMcCwWdD]$/) ||
              colorCode.match(/^@[rRgGyYbBmMcCwWdD]$/) ||
              colorCode.match(/^\{[rRgGyYbBmMcCwWdD]$/)
            ) {
              const c = colorCode.charAt(1);
              colorIndex = standardColorToIndex[c] || 7;
            } else if (colorCode.startsWith("&")) {
              const m = colorCode.match(/^&([rRgGyYbBmMcCwWdD])(\d{3})?$/);
              if (m) {
                if (m[2]) {
                  colorIndex = parseInt(m[2], 10);
                } else {
                  const c = m[1];
                  colorIndex = standardColorToIndex[c] || 7;
                }
              } else if (/^&\d{3}$/.test(colorCode)) {
                colorIndex = parseInt(colorCode.slice(1), 10);
              }
            } else if (colorCode.startsWith("{")) {
              if (colorCode.startsWith("{x") && colorCode.length === 5) {
                colorIndex = parseInt(colorCode.slice(2), 10);
              } else {
                const m = colorCode.match(/^\{([rRgGyYbBmMcCwWdD])(\d{3})?$/);
                if (m) {
                  if (m[2]) {
                    colorIndex = parseInt(m[2], 10);
                  } else {
                    const c = m[1];
                    colorIndex = standardColorToIndex[c] || 7;
                  }
                } else if (/^\{\d{3}$/.test(colorCode)) {
                  colorIndex = parseInt(colorCode.slice(1), 10);
                }
              }
            } else {
              colorIndex = 7;
            }
            converted += wrapColorCode(colorIndex);
            if (newFormat === "ansi") {
              needsReset = true;
            }
          } else if (textContent) {
            converted += textContent;
          }
        });
        // Add ANSI reset at the end if using ANSI format
        if (newFormat === "ansi" && needsReset) {
          converted += "\\033[0m";
        }
        return converted;
      }

      function applyOriginalPattern(text, colors) {
        let result = "";
        let lastColorIndex = null;
        const format = document.getElementById("formatSelector").value;
        
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const colorIndex = colors[i % colors.length];
          if (!/\s/.test(char) && colorIndex !== lastColorIndex) {
            result += wrapColorCode(colorIndex);
            lastColorIndex = colorIndex;
          }
          result += char;
        }
        
        // Add ANSI reset at the end if using ANSI format
        if (format.startsWith("ansi-") && lastColorIndex !== null) {
          const escapeSeq = format === "ansi-rust" ? "\\x1B" : format === "ansi-lua" ? "\\27" : "\\033";
          result += `${escapeSeq}[0m`;
        }
        
        return result;
      }

      function distributeColorsEvenly(text, colors) {
        const n = text.length;
        const c = colors.length;
        if (n === 0) return "";
        const format = document.getElementById("formatSelector").value;
        const baseSize = Math.floor(n / c);
        let remainder = n % c;
        let segments = [];
        let startIndex = 0;
        for (let i = 0; i < c; i++) {
          const segmentSize = baseSize + (remainder > 0 ? 1 : 0);
          remainder = remainder > 0 ? remainder - 1 : remainder;
          const segment = text.slice(startIndex, startIndex + segmentSize);
          startIndex += segmentSize;
          segments.push({ segment, colorIndex: colors[i] });
        }
        let result = "";
        let hasColor = false;
        segments.forEach(({ segment, colorIndex }) => {
          if (!segment) return;
          let lastColorIndex = null;
          for (let i = 0; i < segment.length; i++) {
            const char = segment[i];
            if (!/\s/.test(char) && colorIndex !== lastColorIndex) {
              result += wrapColorCode(colorIndex);
              lastColorIndex = colorIndex;
              hasColor = true;
            }
            result += char;
          }
        });
        
        // Add ANSI reset at the end if using ANSI format
        if (format.startsWith("ansi-") && hasColor) {
          const escapeSeq = format === "ansi-rust" ? "\\x1B" : format === "ansi-lua" ? "\\27" : "\\033";
          result += `${escapeSeq}[0m`;
        }
        
        return result;
      }

      function applySymmetricalPattern(text, colors) {
        const c = colors.length;
        if (c < 2) {
          return applyOriginalPattern(text, colors);
        }
        const format = document.getElementById("formatSelector").value;
        let result = "";
        let lastColorIndex = null;
        const cycleLength = 2 * c - 2;
        for (let i = 0; i < text.length; i++) {
          let mod = i % cycleLength;
          if (mod >= c) {
            mod = cycleLength - mod;
          }
          const colorIndex = colors[mod];
          const char = text[i];
          if (!/\s/.test(char) && colorIndex !== lastColorIndex) {
            result += wrapColorCode(colorIndex);
            lastColorIndex = colorIndex;
          }
          result += char;
        }
        
        // Add ANSI reset at the end if using ANSI format
        if (format.startsWith("ansi-") && lastColorIndex !== null) {
          const escapeSeq = format === "ansi-rust" ? "\\x1B" : format === "ansi-lua" ? "\\27" : "\\033";
          result += `${escapeSeq}[0m`;
        }
        
        return result;
      }


      function formatText(text) {
        const wrapLimit = parseInt(document.getElementById("wrapLimit").value) || 80;
        
        // First, extract all words from the entire text (merging lines)
        const allWords = [];
        let currentWord = "";
        let i = 0;
        
        // Replace newlines with spaces to merge lines
        const mergedText = text.replace(/\n+/g, ' ');
        
        while (i < mergedText.length) {
          const remaining = mergedText.slice(i);
          const colorMatch = remaining.match(/^(\$X[0-9a-fA-F]{6}|\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rRgGyYbBmMcCwWdD](?:\d{3})?|@[rRgGyYbBmMcCwWdD](?:\d{3})?|\&[rRgGyYbBmMcCwWdD](?:\d{3})?|\{[rRgGyYbBmMcCwWdD](?:\d{3})?|\{\d{3}|\&\d{3})/);
          
          if (colorMatch) {
            currentWord += colorMatch[0];
            i += colorMatch[0].length;
          } else {
            const char = mergedText[i];
            if (char === ' ') {
              if (currentWord) {
                allWords.push(currentWord);
                currentWord = "";
              }
            } else {
              currentWord += char;
            }
            i++;
          }
        }
        
        // Don't forget the last word
        if (currentWord) {
          allWords.push(currentWord);
        }
        
        // Now reflow all words into properly formatted lines
        const formattedLines = [];
        let currentLine = "";
        let currentLineLength = 0;
        
        allWords.forEach((word) => {
          // Calculate visible length of word
          const visibleWord = word.replace(
            /\$X[0-9a-fA-F]{6}|\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rRgGyYbBmMcCwWdD](?:\d{3})?|@[rRgGyYbBmMcCwWdD](?:\d{3})?|\&[rRgGyYbBmMcCwWdD](?:\d{3})?|\{[rRgGyYbBmMcCwWdD](?:\d{3})?|\{\d{3}|\&\d{3}/g,
            ""
          );
          const wordLength = visibleWord.length;
          
          if (currentLineLength === 0) {
            // First word on line
            currentLine = word;
            currentLineLength = wordLength;
          } else if (currentLineLength + 1 + wordLength <= wrapLimit) {
            // Word fits on current line with space
            currentLine += " " + word;
            currentLineLength += 1 + wordLength;
          } else {
            // Word doesn't fit, start new line
            formattedLines.push(currentLine);
            currentLine = word;
            currentLineLength = wordLength;
          }
        });
        
        // Add the last line
        if (currentLine) {
          formattedLines.push(currentLine);
        }
        
        return formattedLines.join('\n');
      }


      function applyGradient() {
        const textInput = document.getElementById("textInput");
        const copyableOutput = document.getElementById("copyableOutput");
        const text = originalText;
        const pattern = document.getElementById("patternSelect").value;
        const select = document.getElementById("gradientSelect");
        const invert = document.getElementById("invertGradient").checked;
        const index = select.selectedIndex;
        if (index < 0) return;
        const gradient = gradients[index];
        
        let gradientText = "";
        
        // Check if it's a truecolor gradient
        if (gradient.isTruecolor) {
          // For truecolor gradients, generate using the stored RGB values
          const startColor = invert ? gradient.colors[1] : gradient.colors[0];
          const endColor = invert ? gradient.colors[0] : gradient.colors[1];
          
          if (pattern === "original") {
            gradientText = generateTruecolorGradientFromColors(text, startColor, endColor);
          } else if (pattern === "distributed") {
            gradientText = distributeTruecolorsEvenly(text, startColor, endColor);
          } else if (pattern === "symmetrical") {
            gradientText = applySymmetricalTruecolorPattern(text, startColor, endColor);
          }
        } else {
          // Regular xterm gradient
          const colors = invert ? gradient.colors.slice().reverse() : gradient.colors;
          if (pattern === "original") {
            gradientText = applyOriginalPattern(text, colors);
          } else if (pattern === "distributed") {
            gradientText = distributeColorsEvenly(text, colors);
          } else if (pattern === "symmetrical") {
            gradientText = applySymmetricalPattern(text, colors);
          }
        }
        
        // Keep the input clean, put colored text in copyable output
        textInput.value = text;
        copyableOutput.value = gradientText;
        
        // Restore cursor position if we have one saved
        if (window.savedPlainCursorPos !== undefined) {
          textInput.setSelectionRange(window.savedPlainCursorPos, window.savedPlainCursorPos);
          window.savedPlainCursorPos = undefined;
        }
        
        originalText = text;
        updateOutput(gradientText);
      }

      function generateTruecolorGradientFromColors(str, startColor, endColor) {
        let chars = Array.from(str);
        // count only non-whitespace characters for gradient steps
        let total = chars.filter(c => /\S/.test(c)).length;

        let out = '';
        let nonWhitespaceIdx = 0;
        let lastAppliedColorHex = null;
        
        const format = document.getElementById("formatSelector").value;
        const useAnsi = format.startsWith("ansi-");

        for (let char of chars) {
          if (/\s/.test(char)) {
            out += char;
          } else {
            // Calculate interpolation factor (t) based on non-whitespace character index
            let t = total > 1 ? nonWhitespaceIdx / (total - 1) : 0;

            // Interpolate RGB components
            let r = Math.round(startColor.r + (endColor.r - startColor.r) * t);
            let g = Math.round(startColor.g + (endColor.g - startColor.g) * t);
            let b = Math.round(startColor.b + (endColor.b - startColor.b) * t);

            // Format based on selected format
            let colorCode;
            if (useAnsi) {
              // ANSI 24-bit true color format
              colorCode = `\\033[38;2;${r};${g};${b}m`;
            } else {
              // Default to $X format
              let hex = toHex(r) + toHex(g) + toHex(b);
              colorCode = '$X' + hex;
            }

            // Only apply color code if it's different from the last one
            if (colorCode !== lastAppliedColorHex) {
                 out += colorCode;
                 lastAppliedColorHex = colorCode;
            }

            out += char;
            nonWhitespaceIdx++;
          }
        }
        
        // Add ANSI reset at the end if using ANSI format
        if (useAnsi && lastAppliedColorHex) {
          out += "\\033[0m";
        }
        
        return out;
      }

      function distributeTruecolorsEvenly(text, startColor, endColor) {
        const n = text.length;
        if (n === 0) return "";
        
        // Create multiple color steps for distribution (similar to how xterm gradients work)
        const numSteps = 10; // Create 10 color steps between start and end
        const colors = [];
        
        for (let i = 0; i < numSteps; i++) {
          const t = i / (numSteps - 1);
          colors.push({
            r: Math.round(startColor.r + (endColor.r - startColor.r) * t),
            g: Math.round(startColor.g + (endColor.g - startColor.g) * t),
            b: Math.round(startColor.b + (endColor.b - startColor.b) * t)
          });
        }
        
        // Now distribute these colors evenly across the text
        const c = colors.length;
        const baseSize = Math.floor(n / c);
        let remainder = n % c;
        let segments = [];
        let startIndex = 0;
        
        for (let i = 0; i < c; i++) {
          const segmentSize = baseSize + (remainder > 0 ? 1 : 0);
          remainder = remainder > 0 ? remainder - 1 : remainder;
          const segment = text.slice(startIndex, startIndex + segmentSize);
          startIndex += segmentSize;
          segments.push({ segment, color: colors[i] });
        }
        
        let result = "";
        segments.forEach(({ segment, color }) => {
          if (!segment) return;
          let lastAppliedColorHex = null;
          for (let i = 0; i < segment.length; i++) {
            const char = segment[i];
            if (!/\s/.test(char)) {
              const hex = toHex(color.r) + toHex(color.g) + toHex(color.b);
              const colorCode = '$X' + hex;
              
              if (colorCode !== lastAppliedColorHex) {
                result += colorCode;
                lastAppliedColorHex = colorCode;
              }
            }
            result += char;
          }
        });
        
        return result;
      }

      function applySymmetricalTruecolorPattern(text, startColor, endColor) {
        let chars = Array.from(text);
        let total = chars.length;
        if (total === 0) return "";
        
        let out = '';
        let lastAppliedColorHex = null;
        
        for (let i = 0; i < total; i++) {
          const char = chars[i];
          if (!/\s/.test(char)) {
            // Calculate position in symmetrical pattern (0 to 1 to 0)
            let t;
            if (i <= total / 2) {
              t = (i * 2) / total;
            } else {
              t = 2 - (i * 2) / total;
            }
            
            // Interpolate RGB components
            let r = Math.round(startColor.r + (endColor.r - startColor.r) * t);
            let g = Math.round(startColor.g + (endColor.g - startColor.g) * t);
            let b = Math.round(startColor.b + (endColor.b - startColor.b) * t);
            
            const hex = toHex(r) + toHex(g) + toHex(b);
            const colorCode = '$X' + hex;
            
            if (colorCode !== lastAppliedColorHex) {
              out += colorCode;
              lastAppliedColorHex = colorCode;
            }
          }
          out += char;
        }
        return out;
      }

      function updateOutput(coloredText) {
        // Use colored text if provided, otherwise get from copyable output
        const textToRender = coloredText || document.getElementById("copyableOutput").value || document.getElementById("textInput").value;
        document.getElementById("output").innerHTML = renderXterm(textToRender);
        
        // Update character counter based on clean text
        const cleanText = document.getElementById("textInput").value;
        document.getElementById("charCounter").textContent = `Total Characters: ${cleanText.length}`;
      }

      function updateFont() {
        const selectedFont = document.getElementById("fontSelector").value;
        document.body.style.fontFamily = selectedFont;
      }

      function updateGradientPreview() {
        const select = document.getElementById("gradientSelect");
        const index = select.selectedIndex;
        if (index < 0) return;
        const gradient = gradients[index];
        const preview = document.getElementById("gradientPreview");
        
        if (gradient.isTruecolor) {
          // Handle truecolor gradients
          const invert = document.getElementById("invertGradient").checked;
          const startColor = invert ? gradient.colors[1] : gradient.colors[0];
          const endColor = invert ? gradient.colors[0] : gradient.colors[1];
          preview.style.background = `linear-gradient(to right, rgb(${startColor.r},${startColor.g},${startColor.b}), rgb(${endColor.r},${endColor.g},${endColor.b}))`;
        } else if (gradient.colors.length > 1) {
          const invert = document.getElementById("invertGradient").checked;
          const colors = invert ? gradient.colors.slice().reverse() : gradient.colors;
          preview.style.background = `linear-gradient(to right, ${colors
            .map(xtermToRgbHex)
            .join(", ")})`;
        } else if (gradient.colors.length === 1) {
          preview.style.background = `${xtermToRgbHex(gradient.colors[0])}`;
        } else {
          preview.style.background = `black`;
        }
      }

      function createGradientOptionPreviews() {
        const select = document.getElementById("gradientSelect");
        Array.from(select.options).forEach((option, index) => {
          const gradient = gradients[index];
          const gradientCanvas = document.createElement("canvas");
          gradientCanvas.width = 100;
          gradientCanvas.height = 20;
          const ctx = gradientCanvas.getContext("2d");
          
          if (gradient.isTruecolor) {
            // Handle truecolor gradients
            const gradientStyle = ctx.createLinearGradient(0, 0, gradientCanvas.width, 0);
            const startColor = gradient.colors[0];
            const endColor = gradient.colors[1];
            gradientStyle.addColorStop(0, `rgb(${startColor.r},${startColor.g},${startColor.b})`);
            gradientStyle.addColorStop(1, `rgb(${endColor.r},${endColor.g},${endColor.b})`);
            ctx.fillStyle = gradientStyle;
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          } else if (gradient.colors.length > 1) {
            const gradientStyle = ctx.createLinearGradient(0, 0, gradientCanvas.width, 0);
            gradient.colors.forEach((color, idx) => {
              const stopPosition = gradient.colors.length > 1 ? idx / (gradient.colors.length - 1) : 0;
              gradientStyle.addColorStop(stopPosition, xtermToRgbHex(color));
            });
            ctx.fillStyle = gradientStyle;
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          } else if (gradient.colors.length === 1) {
            ctx.fillStyle = xtermToRgbHex(gradient.colors[0]);
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          } else {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
          }
          const dataURL = gradientCanvas.toDataURL();
          option.style.backgroundImage = `url(${dataURL})`;
          option.style.backgroundSize = "cover";
          option.style.backgroundRepeat = "no-repeat";
          option.style.paddingLeft = "30px";
        });
      }

      // --- Persistence using localStorage ---
      function loadCustomGradients() {
        const stored = localStorage.getItem("customGradients");
        if (stored) {
          try {
            return JSON.parse(stored);
          } catch (e) {
            return [];
          }
        }
        return [];
      }

      function saveCustomGradients() {
        localStorage.setItem("customGradients", JSON.stringify(customGradients));
      }

      // --- Built-in and Custom Gradients ---
      const builtInGradients = [
        { name: "Pastelbow", colors: [226, 190, 119, 84, 50, 51, 45, 69, 99, 165, 201, 200, 205, 204, 209, 215, 220] },
        { name: "Rainbow", colors: [196, 208, 226, 46, 51, 87] },
        { name: "Fire", colors: [208, 166, 124, 94, 95, 167] },
        { name: "Ocean", colors: [59, 95, 131, 167, 209, 215] },
        { name: "Mystic", colors: [124, 132, 138, 145, 150, 155] },
        { name: "Shadow Eclipse", colors: [59, 95, 131, 167] },
        { name: "Frosty Dawn", colors: [209, 215, 221] },
        { name: "Eternal Ember", colors: [208, 166, 124, 94, 95] },
        { name: "Ethereal Vex", colors: [208, 124, 94, 100, 136] },
        { name: "Night Whisper", colors: [59, 95, 131, 167] },
        { name: "Crystal Duality", colors: [95, 59] },
        { name: "Obsidian Mirage", colors: [61, 62, 97, 96] },
        { name: "Moonlight Trio", colors: [132, 131, 167] },
        { name: "Dusk Crown", colors: [127, 133, 139] },
        { name: "Dream Tides", colors: [145, 151, 150, 151] },
        { name: "Mystic Charm", colors: [145, 139, 133, 127] },
        { name: "Fallen Mark", colors: [221, 220, 178, 172] },
        { name: "Destiny Shard", colors: [130, 94, 196] },
        { name: "Shattered Echo", colors: [124, 88, 52] },
        { name: "Stormsong", colors: [172, 178, 220] },
        { name: "Gale Helix", colors: [221, 227, 220] },
        { name: "Inferno Crest", colors: [174, 102, 109] },
        { name: "Endless Night", colors: [59, 95, 131, 167] },
        { name: "Abyss Sigil", colors: [131, 95, 59] },
        { name: "Sunlit Peaks", colors: [157, 121, 85, 49, 50] },
        { name: "Shattered Star", colors: [51, 87] },
        { name: "Endless Dreams", colors: [96, 97, 103, 97] },
        { name: "Starlight Despair", colors: [96, 60, 61, 97, 96] },
        {
          name: "Dream Eclipse",
          colors: [95, 101, 107, 113, 119, 113, 107, 101],
        },
        { name: "Everlasting Light", colors: [69, 68, 67, 61] },
        { name: "Ancient Havens", colors: [60, 67, 61, 60] },
        { name: "Eternal Radiance", colors: [226, 227, 228, 229] },
        { name: "Glory Flares", colors: [230, 194, 193, 226] },
        { name: "Gilded Infinity", colors: [201, 207, 213, 219] },
        { name: "Arcane Symbol", colors: [225, 231, 225, 219] },
        { name: "Shattered Stars", colors: [230, 229, 228, 227] },
        { name: "Eclipsed Glory", colors: [226, 190, 154] },
        { name: "Mystic Rays", colors: [230, 228, 222, 216] },
        { name: "Flickering Fire", colors: [230, 228, 222, 216] },
        { name: "Burning Ash", colors: [214, 178, 130, 94, 95] },
        { name: "Silent Embrace", colors: [214, 178] },
        { name: "Eternal Breeze", colors: [124, 130, 136] },
        { name: "Flowing Mist", colors: [142, 148, 154, 190, 226] },
        { name: "Sacred Dreams", colors: [96, 103, 110, 111] },
        { name: "Ember Relic", colors: [116, 121, 157, 151] },
        { name: "Enigmatic Shadows", colors: [72, 85, 84, 78] },
        { name: "Ancient Whisper", colors: [72, 66, 85, 84] },
        { name: "Eclipsed Crown", colors: [220, 214, 208, 209, 210] },
        { name: "Eternal Shards", colors: [174, 138, 102] },
        { name: "Mystery Echo", colors: [59, 95, 131, 124, 88, 52] },
        { name: "Olympian Dreams", colors: [111, 110, 153, 195, 153] },
        { name: "Crown Armor", colors: [110, 111] },
        { name: "Whispering Winds", colors: [145, 188, 181, 174, 131] },
        { name: "Titan Mark", colors: [167, 226] },
        { name: "Shattered Worlds", colors: [187, 186, 144, 138, 132] },
        { name: "Ethereal Machine", colors: [131, 167] },
        { name: "Mystic Wisdom", colors: [137, 138, 139, 175, 211] },
        { name: "Single Hue", colors: [139] },
        { name: "Radiant Arcane", colors: [27, 63, 99, 135, 171] },
        { name: "Warden's Hue", colors: [207] },
        { name: "Endless Nightfall", colors: [51, 87, 123, 159] },
        { name: "Eclipse Shard", colors: [195, 231] },
        { name: "Elemental Fury", colors: [81, 111, 141, 171, 141] },
        { name: "Steel Eclipse", colors: [33, 39, 45, 39, 33] },
        { name: "Ghoul Glow", colors: [154, 155, 191, 190, 191, 155, 154] },
        {
          name: "Celestial Scales",
          colors: [81, 87, 159, 194, 192, 227, 220, 226, 227, 192, 159, 87, 81],
        },
        {
          name: "Solar Flare",
          colors: [196, 208, 220, 226, 220, 208, 196, 33],
        },
        {
          name: "Cerebral Rift",
          colors: [175, 174, 168, 169, 175, 174, 168, 169],
        },
        { name: "Abyssal Armor", colors: [69, 68, 67, 61, 60, 61, 67, 68, 69] },
        {
          name: "Sunset Wail",
          colors: [231, 225, 218, 211, 204, 197, 204, 211, 218, 225, 231],
        },
        { name: "Verdict Veil", colors: [142, 143, 144, 150, 151] },
        { name: "Stratosphere Surge", colors: [41, 87, 159, 194, 192] },
        { name: "Venomous Gaze", colors: [103, 102, 138, 174, 78] },
        { name: "Moonlit Veil", colors: [220, 221, 227, 228] },
        {
          name: "Gradient_Ex_Sequence_1",
          colors: [167, 131, 132, 95, 96, 97, 61, 62, 61, 97, 96, 95, 132, 131, 167],
        },
        {
          name: "Gradient_Ex_Sequence_2",
          colors: [127, 133, 139, 145, 151, 150, 151, 145, 139, 133, 127],
        },
        {
          name: "Gradient_Ex_Sequence_3",
          colors: [221, 220, 178, 172, 130, 94, 196, 160, 124, 88, 52],
        },
        {
          name: "Gradient_Ex_Sequence_4",
          colors: [172, 178, 220, 221, 227, 221, 220, 178, 172],
        },
        {
          name: "Gradient_Ex_Sequence_5",
          colors: [59, 95, 131, 167, 131, 95, 59],
        },
        {
          name: "Gradient_Ex_Sequence_6",
          colors: [157, 121, 85, 49, 50, 51, 87, 123, 87, 51, 50, 49],
        },
        {
          name: "Gradient_Ex_Sequence_7",
          colors: [96, 97, 103, 97, 96, 60, 61, 97, 96],
        },
        {
          name: "Gradient_Ex_Sequence_8",
          colors: [95, 101, 107, 113, 119, 113, 107, 101, 95, 101],
        },
        {
          name: "Gradient_Ex_Sequence_9",
          colors: [69, 68, 67, 61, 60, 69, 68, 67, 61, 60],
        },
        {
          name: "Gradient_Ex_Sequence_10",
          colors: [226, 227, 228, 229, 230, 194, 193],
        },
        {
          name: "Gradient_Ex_Sequence_11",
          colors: [201, 207, 213, 219, 225, 231, 225, 219, 213, 207, 201, 200],
        },
        {
          name: "Gradient_Ex_Sequence_12",
          colors: [230, 229, 228, 227, 226, 190, 154, 190, 226, 227, 228, 229],
        },
        {
          name: "Gradient_Ex_Sequence_13",
          colors: [230, 228, 222, 216, 230, 228, 222, 216, 215],
        },
        {
          name: "Gradient_Ex_Sequence_14",
          colors: [214, 178, 130, 94, 95, 59, 214, 178, 130, 94, 95, 59],
        },
        {
          name: "Gradient_Ex_Sequence_15",
          colors: [124, 130, 136, 142, 148, 154, 190, 226, 228],
        },
        {
          name: "Gradient_Ex_Sequence_16",
          colors: [96, 103, 110, 111, 116, 121, 157, 151, 145, 139],
        },
        {
          name: "Gradient_Ex_Sequence_17",
          colors: [72, 85, 84, 78, 72, 66, 85, 84, 72],
        },
        {
          name: "Gradient_Ex_Sequence_18",
          colors: [220, 214, 208, 209, 210, 174, 138, 102, 109, 66, 67],
        },
        {
          name: "Gradient_Ex_Sequence_19",
          colors: [59, 95, 131, 124, 88, 52],
        },
        {
          name: "Gradient_Ex_Sequence_20",
          colors: [111, 110, 153, 195, 153, 110, 111],
        },
        {
          name: "Gradient_Ex_Sequence_21",
          colors: [145, 188, 181, 174, 131, 167, 145, 188, 181, 174, 131, 167],
        },
        {
          name: "Gradient_Ex_Sequence_22",
          colors: [187, 186, 144, 138, 132, 131, 167, 131, 132, 138, 144, 186, 187],
        },
        {
          name: "Gradient_Ex_Sequence_23",
          colors: [137, 138, 139, 175, 211, 139, 138, 173, 210, 211],
        },
        {
          name: "Gradient_Ex_Sequence_24",
          colors: [27, 63, 99, 135, 171, 207, 171, 135, 99],
        },
        {
          name: "Gradient_Ex_Sequence_25",
          colors: [51, 87, 123, 159, 195, 231, 195, 159, 123],
        },
        {
          name: "Gradient_Ex_Sequence_26",
          colors: [81, 111, 141, 171],
        },
        {
          name: "Gradient Sequence 27",
          colors: [96, 96, 96, 96, 60, 60, 60, 60, 61, 61, 61, 61, 97, 97, 97, 97],
        },
        {
          name: "Gradient Sequence 28",
          colors: [71, 83, 119, 155, 191, 227, 191, 155, 119],
        },
        {
          name: "Gradient Sequence 29",
          colors: [81, 87, 123, 159, 195, 231, 195, 159, 123],
        },
        {
          name: "Gradient Sequence 30",
          colors: [120, 121, 122, 123, 124, 125, 126, 127, 128, 129],
        },
        {
          name: "Gradient Sequence 31",
          colors: [161, 198, 126, 90, 91, 97, 108, 109, 110, 111, 71, 72, 73, 74, 75],
        },
        {
          name: "Gradient Sequence 32",
          colors: [33, 32, 31, 30, 29, 28, 29, 30, 31],
        },
        { name: "Gradient Sequence 33", colors: [96, 103, 109, 110, 153, 195] },
        {
          name: "Gradient Sequence 34",
          colors: [148, 142, 136, 137, 216, 102, 66],
        },
        {
          name: "Gradient Sequence 35",
          colors: [22, 23, 30, 36, 43, 50, 43, 36, 30],
        },
        {
          name: "Gradient Sequence 36",
          colors: [94, 53, 23, 29, 35, 41, 47, 41, 35, 29, 23, 53, 94],
        },
        {
          name: "Gradient Sequence 37",
          colors: [131, 94, 100, 144, 187, 186, 144, 138, 132],
        },
        {
          name: "Gradient Sequence 38",
          colors: [89, 90, 91, 92, 93, 94, 95, 96, 97],
        },
        { name: "Lush Meadow", colors: [46, 82, 118, 154, 190] },
        { name: "Midnight Shadows", colors: [16, 22, 28, 34, 40, 46] },
        { name: "Sunset Blaze", colors: [202, 166, 130, 94, 58] },
        {
          name: "Wailing Abomination",
          colors: [166, 172, 130, 136, 94, 100, 58, 64, 106, 112, 142, 148],
        },
        {
          name: "Putrid Funk",
          colors: [130, 136, 142, 148, 154, 148, 142, 136, 135, 134, 133, 132],
        }
      ];

      // Load custom gradients from localStorage and merge them.
      let customGradients = loadCustomGradients();
      let gradients = builtInGradients.concat(customGradients);
      let originalText = "";

      function populateGradientSelect() {
        const select = document.getElementById("gradientSelect");
        select.innerHTML = "";
        gradients.forEach((g, idx) => {
          const option = document.createElement("option");
          option.value = g.name;
          option.textContent = g.name;
          option.dataset.gradientIndex = idx;
          select.appendChild(option);
        });
        createGradientOptionPreviews();
      }

      function onGradientChange() {
        updateGradientPreview();
        applyGradient();
      }

      function onPatternChange() {
        applyGradient();
      }

      function onTextPaste(event) {
        const mode = getSelectedMode();
        
        if (mode === "view") {
          // In viewer mode, let the paste happen normally - don't interfere
          return;
        }
        
        // Get the pasted text from clipboard
        const pastedText = (event.clipboardData || window.clipboardData).getData('text');
        
        // Check if the pasted text has color codes
        const hasColorCodes = /\$X[0-9a-fA-F]{6}|\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rRgGyYbBmMcCwWdD](?:\d{3})?|@[rRgGyYbBmMcCwWdD](?:\d{3})?|\&[rRgGyYbBmMcCwWdD](?:\d{3})?|\{[rRgGyYbBmMcCwWdD](?:\d{3})?|\{\d{3}|\&\d{3}/.test(pastedText);
        
        if (hasColorCodes) {
          // Prevent default paste behavior
          event.preventDefault();
          
          // Strip color codes for the input box (clean text for editing)
          const cleanText = pastedText.replace(
            /\$X[0-9a-fA-F]{6}|\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rRgGyYbBmMcCwWdD](?:\d{3})?|@[rRgGyYbBmMcCwWdD](?:\d{3})?|\&[rRgGyYbBmMcCwWdD](?:\d{3})?|\{[rRgGyYbBmMcCwWdD](?:\d{3})?|\{\d{3}|\&\d{3}/g,
            ""
          );
          
          // Get cursor position and insert clean text
          const textInput = document.getElementById("textInput");
          const startPos = textInput.selectionStart;
          const endPos = textInput.selectionEnd;
          const currentValue = textInput.value;
          
          // Insert clean text at cursor position
          const newValue = currentValue.substring(0, startPos) + cleanText + currentValue.substring(endPos);
          textInput.value = newValue;
          
          // Set cursor position after inserted text
          const newCursorPos = startPos + cleanText.length;
          textInput.setSelectionRange(newCursorPos, newCursorPos);
          
          // Update originalText for edit mode
          originalText = newValue;
          
          // Apply gradient to the updated text (this will properly update both preview and copyable output)
          applyGradient();
        }
        // If no color codes, let the normal paste happen and onTextInput will handle it
      }

      function onTextInput(event) {
        const mode = getSelectedMode();
        const textInput = document.getElementById("textInput");
        const text = textInput.value;
        const cursorPos = textInput.selectionStart;
        
        if (mode === "edit") {
          // Text is already clean, just store it
          originalText = text;
          
          // Store the cursor position to restore after gradient
          window.savedPlainCursorPos = cursorPos;
          
          applyGradient();
        } else {
          // In viewer mode, update copyable output and preview
          document.getElementById("copyableOutput").value = text;
          updateOutput();
        }
      }

      function getSelectedMode() {
        const modes = document.getElementsByName("mode");
        for (const mode of modes) {
          if (mode.checked) return mode.value;
        }
        return "edit";
      }

      const modeSelectors = document.getElementsByName("mode");
      modeSelectors.forEach((modeSelector) => {
        modeSelector.addEventListener("change", () => {
          if (getSelectedMode() === "view") {
            document.getElementById("gradientControls").classList.add("disabled");
          } else {
            document.getElementById("gradientControls").classList.remove("disabled");
          }
          updateOutput();
        });
      });

      // Toggle Custom Gradient Section
      document.getElementById("toggleCustomGradientButton").addEventListener("click", function () {
        const addGradientDiv = document.getElementById("addGradient");
        if (addGradientDiv.style.display === "none" || addGradientDiv.style.display === "") {
          addGradientDiv.style.display = "block";
          this.value = "Hide custom gradient";
        } else {
          addGradientDiv.style.display = "none";
          this.value = "Create custom gradient";
        }
      });

      // Random gradient button event listener
      document.getElementById("randomGradientButton").addEventListener("click", function () {
        const textInput = document.getElementById("textInput");
        const copyableOutput = document.getElementById("copyableOutput");
        const text = textInput.value;
        
        if (!text) {
          alert("Please enter some text first!");
          return;
        }
        
        // Generate random gradient with truecolor
        const gradientText = generateRandomTruecolorGradient(text);
        
        // Update copyable output
        copyableOutput.value = gradientText;
        
        // Update the preview
        updateOutput(gradientText);
        
        // Store the last generated gradient info for saving
        window.lastGeneratedGradient = gradientText;
        
        // Show the save button
        document.getElementById("saveRandomGradientButton").style.display = "inline-block";
      });

      // Save random gradient button event listener
      document.getElementById("saveRandomGradientButton").addEventListener("click", function () {
        if (!window.lastGeneratedGradient) return;
        
        // Extract the start and end colors from the generated text
        const colorMatches = window.lastGeneratedGradient.match(/\$X([0-9a-fA-F]{6})/g);
        if (colorMatches && colorMatches.length >= 2) {
          const startHex = colorMatches[0].slice(2);
          const endHex = colorMatches[colorMatches.length - 1].slice(2);
          
          // Prompt for gradient name
          const gradientName = prompt("Enter a name for this gradient:", `Random Gradient ${new Date().toLocaleTimeString()}`);
          if (gradientName) {
            // Store as truecolor gradient
            const startRgb = {
              r: parseInt(startHex.slice(0, 2), 16),
              g: parseInt(startHex.slice(2, 4), 16),
              b: parseInt(startHex.slice(4, 6), 16)
            };
            const endRgb = {
              r: parseInt(endHex.slice(0, 2), 16),
              g: parseInt(endHex.slice(2, 4), 16),
              b: parseInt(endHex.slice(4, 6), 16)
            };
            
            // Add to custom gradients with truecolor flag
            customGradients.push({
              name: gradientName,
              colors: [startRgb, endRgb],
              isTruecolor: true
            });
            saveCustomGradients();
            gradients = builtInGradients.concat(customGradients);
            populateGradientSelect();
            
            // Select the newly created gradient
            const select = document.getElementById("gradientSelect");
            select.value = gradientName;
            updateGradientPreview();
            
            // Hide the save button
            this.style.display = "none";
          }
        }
      });

      // Toggle Manage Custom Gradients Section
      document.getElementById("toggleManageCustomGradients").addEventListener("click", function () {
        const manageDiv = document.getElementById("manageCustomGradients");
        if (manageDiv.style.display === "none" || manageDiv.style.display === "") {
          manageDiv.style.display = "block";
          this.value = "Hide custom gradients";
          populateCustomGradientsList();
        } else {
          manageDiv.style.display = "none";
          this.value = "Manage custom gradients";
        }
      });

      // Update the preview in the create custom gradient form
      function updateCustomGradientPreview() {
        const codesStr = document.getElementById("newGradientCodes").value.trim();
        if (!codesStr) {
          document.getElementById("customGradientPreview").style.background = "";
          return;
        }
        const codes = codesStr.split(/\s+/).map(item => parseInt(item, 10));
        if (codes.some(code => isNaN(code) || code < 0 || code > 255)) {
          document.getElementById("customGradientPreview").style.background = "";
          return;
        }
        const colors = codes.map(xtermToRgbHex);
        let backgroundStyle = "";
        if (colors.length > 1) {
          backgroundStyle = `linear-gradient(to right, ${colors.join(", ")})`;
        } else if (colors.length === 1) {
          backgroundStyle = colors[0];
        }
        document.getElementById("customGradientPreview").style.background = backgroundStyle;
      }
      document.getElementById("newGradientCodes").addEventListener("input", updateCustomGradientPreview);

      // Remove "invalid" class on input when valid
      document.getElementById("newGradientName").addEventListener("input", function () {
        if (this.validity.valid) this.classList.remove("invalid");
      });
      document.getElementById("newGradientCodes").addEventListener("input", function () {
        if (this.validity.valid) this.classList.remove("invalid");
      });

      // This function adds the gradient and verifies valid color codes.
      function verifyAndAddGradient() {
        const gName = document.getElementById("newGradientName").value;
        const gColors = [];
        const colorCodes = document.getElementById("newGradientCodes").value.split(" ");
        const wasConverted = colorCodes.every((item) => {
          const conversion = parseInt(item);
          if (!isNaN(conversion) && conversion >= 0 && conversion <= 255) {
            gColors.push(conversion);
            return true;
          } else {
            return false;
          }
        });
        if (wasConverted) {
          customGradients.push({
            name: gName,
            colors: gColors
          });
          saveCustomGradients();
          gradients = builtInGradients.concat(customGradients);
          populateGradientSelect();
          document.getElementById("newGradientName").value = "";
          document.getElementById("newGradientCodes").value = "";
          document.getElementById("customGradientPreview").style.background = "";
        } else {
          alert("Color codes must be a space separated list of numbers between 0 and 255.");
        }
      }

      // Ignore the click if the input isn't valid and trigger shake animation.
      function addGradientClick() {
        const nameInput = document.getElementById("newGradientName");
        const codesInput = document.getElementById("newGradientCodes");
        if (nameInput.validity.valid && codesInput.validity.valid) {
          verifyAndAddGradient();
        } else {
          if (!nameInput.validity.valid) {
            nameInput.classList.add("invalid", "shake");
            nameInput.addEventListener("animationend", () => {
              nameInput.classList.remove("shake");
            }, { once: true });
          }
          if (!codesInput.validity.valid) {
            codesInput.classList.add("invalid", "shake");
            codesInput.addEventListener("animationend", () => {
              codesInput.classList.remove("shake");
            }, { once: true });
          }
        }
      }
      document.getElementById("newGradientProcess").addEventListener("click", addGradientClick);

      // --- Editing Custom Gradients in the Management Section ---

      // Update the preview for an editable custom gradient
      function updateEditGradientPreview(gradient, previewBox) {
        if (gradient.isTruecolor) {
          // Handle truecolor gradients
          const startColor = gradient.colors[0];
          const endColor = gradient.colors[1];
          previewBox.style.background = `linear-gradient(to right, rgb(${startColor.r},${startColor.g},${startColor.b}), rgb(${endColor.r},${endColor.g},${endColor.b}))`;
        } else {
          // Handle xterm gradients
          const codesString = gradient.colors.join(" ");
          const codesArr = codesString.trim().split(/\s+/).map(item => parseInt(item, 10));
          if (codesArr.some(code => isNaN(code) || code < 0 || code > 255)) {
            previewBox.style.background = "";
            return;
          }
          const colors = codesArr.map(xtermToRgbHex);
          let backgroundStyle = "";
          if (colors.length > 1) {
            backgroundStyle = `linear-gradient(to right, ${colors.join(", ")})`;
          } else if (colors.length === 1) {
            backgroundStyle = colors[0];
          }
          previewBox.style.background = backgroundStyle;
        }
      }

      // Populate the list of custom gradients for management (with inline editing)
      function populateCustomGradientsList() {
        const container = document.getElementById("customGradientsList");
        container.innerHTML = "";
        if (customGradients.length === 0) {
          container.innerHTML = "<p>No custom gradients added.</p>";
          return;
        }
        customGradients.forEach((grad, index) => {
          const gradDiv = document.createElement("div");
          gradDiv.classList.add("custom-gradient-item");

          // Preview box
          const previewBox = document.createElement("div");
          previewBox.classList.add("custom-gradient-preview");
          // Initially update preview
          updateEditGradientPreview(grad, previewBox);

          // Name input
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.classList.add("edit-gradient-name");
          nameInput.value = grad.name;

          if (grad.isTruecolor) {
            // For truecolor gradients, show them as read-only
            const colorInfo = document.createElement("span");
            colorInfo.style.marginLeft = "10px";
            colorInfo.style.color = "#888";
            colorInfo.textContent = "Truecolor gradient (non-editable)";
            
            // Remove button
            const removeBtn = document.createElement("button");
            removeBtn.textContent = "Remove";
            removeBtn.style.marginLeft = "10px";
            removeBtn.addEventListener("click", function() {
              removeCustomGradient(index);
            });

            gradDiv.appendChild(previewBox);
            gradDiv.appendChild(nameInput);
            gradDiv.appendChild(colorInfo);
            gradDiv.appendChild(removeBtn);
          } else {
            // For xterm gradients, keep the editable interface
            // Codes input
            const codesInput = document.createElement("input");
            codesInput.type = "text";
            codesInput.classList.add("edit-gradient-codes");
            codesInput.value = grad.colors.join(" ");
            codesInput.addEventListener("input", function() {
              const tempGrad = { ...grad, colors: this.value.trim().split(/\s+/).map(c => parseInt(c, 10)) };
              updateEditGradientPreview(tempGrad, previewBox);
            });

            // Save button
            const saveBtn = document.createElement("button");
            saveBtn.textContent = "Save";
            saveBtn.addEventListener("click", function() {
              saveEditedGradient(index, nameInput, codesInput);
            });

            // Remove button
            const removeBtn = document.createElement("button");
            removeBtn.textContent = "Remove";
            removeBtn.addEventListener("click", function() {
              removeCustomGradient(index);
            });

            gradDiv.appendChild(previewBox);
            gradDiv.appendChild(nameInput);
            gradDiv.appendChild(codesInput);
            gradDiv.appendChild(saveBtn);
            gradDiv.appendChild(removeBtn);
          }

          container.appendChild(gradDiv);
        });
      }

      // Save the edited custom gradient
      function saveEditedGradient(index, nameInput, codesInput) {
        const newName = nameInput.value.trim();
        const codesStr = codesInput.value.trim();
        if (!newName.match(/^[\w\s]+$/)) {
          nameInput.classList.add("invalid", "shake");
          nameInput.addEventListener("animationend", () => {
            nameInput.classList.remove("shake");
          }, { once: true });
          return;
        }
        if (!codesStr.match(/^(?:[0-9]{1,3}(?:\s+[0-9]{1,3})*)$/)) {
          codesInput.classList.add("invalid", "shake");
          codesInput.addEventListener("animationend", () => {
            codesInput.classList.remove("shake");
          }, { once: true });
          return;
        }
        const codesArr = codesStr.split(/\s+/).map(item => parseInt(item, 10));
        if (codesArr.some(code => isNaN(code) || code < 0 || code > 255)) {
          codesInput.classList.add("invalid", "shake");
          codesInput.addEventListener("animationend", () => {
            codesInput.classList.remove("shake");
          }, { once: true });
          return;
        }
        customGradients[index].name = newName;
        customGradients[index].colors = codesArr;
        saveCustomGradients();
        gradients = builtInGradients.concat(customGradients);
        populateGradientSelect();
        populateCustomGradientsList();
      }

      // Remove a custom gradient
      function removeCustomGradient(index) {
        customGradients.splice(index, 1);
        saveCustomGradients();
        gradients = builtInGradients.concat(customGradients);
        populateGradientSelect();
        populateCustomGradientsList();
      }


      function initialize() {
        populateGradientSelect();
        updateGradientPreview();
        updateOutput();
        // If the create-gradient form already has color codes, update its preview.
        updateCustomGradientPreview();
      }

      document.getElementById("fontSelector").addEventListener("change", updateFont);
      document.getElementById("textInput").addEventListener("input", onTextInput);
      document.getElementById("textInput").addEventListener("paste", onTextPaste);
      document.getElementById("gradientSelect").addEventListener("change", onGradientChange);
      document.getElementById("patternSelect").addEventListener("change", onPatternChange);
      document.getElementById("invertGradient").addEventListener("change", onGradientChange);
      
      // Format conversion event
      document.getElementById("formatSelector").addEventListener("change", function () {
        console.log("Format selector changed to:", this.value);
        const text = document.getElementById("textInput").value;
        const newFormat = this.value;
        const converted = convertColorCodesToFormat(text, newFormat);
        document.getElementById("textInput").value = converted;
        
        const copyableOutput = document.getElementById("copyableOutput");
        
        // Show/hide ANSI help text
        document.getElementById("ansiHelp").style.display = newFormat.startsWith("ansi-") ? "inline" : "none";
        
        if (getSelectedMode() === "edit") {
          // In edit mode, convert existing copyable output if it has content
          if (copyableOutput.value) {
            const convertedCopyable = convertColorCodesToFormat(copyableOutput.value, newFormat);
            copyableOutput.value = convertedCopyable;
          }
          
          originalText = converted.replace(
            /\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|@n|\$[rKrRgGyYbBmMcCwWdD]|@[rKrRgGyYbBmMcCwWdD]|\{[rKrRgGyYbBmMcCwWdD]|\&[rKrRgGyYbBmMcCwWdD](?:\d{3})?|\&\d{3}/g,
            ""
          );
          applyGradient();
        } else {
          // In viewer mode, always update copyable output with the converted text
          copyableOutput.value = converted;
          updateOutput();
        }
      });

      // Format button event listener
      document.getElementById("formatButton").addEventListener("click", function() {
        const textInput = document.getElementById("textInput");
        const formattedText = formatText(textInput.value);
        textInput.value = formattedText;
        
        if (getSelectedMode() === "edit") {
          // Update original text with the formatted clean text
          originalText = formattedText;
          applyGradient();
        } else {
          // In viewer mode, also update copyable output
          document.getElementById("copyableOutput").value = formattedText;
          updateOutput();
        }
      });

      // Copy button functionality
      document.getElementById("copyButton").addEventListener("click", async function() {
        const copyableOutput = document.getElementById("copyableOutput");
        const copyButton = this;
        let textToCopy = copyableOutput.value;
        
        // Special handling for ANSI format - ensure proper escape characters
        const format = document.getElementById("formatSelector").value;
        if (format.startsWith("ansi-")) {
          // For ANSI, the text already contains \u001b which should work
          // But we'll add a note for the user
          console.log("Copying ANSI codes. To test in terminal, use: echo -e \"" + textToCopy.substring(0, 50) + "...\"");
        }
        
        try {
          // Use the modern Clipboard API if available
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(textToCopy);
          } else {
            // Fallback for older browsers
            copyableOutput.select();
            copyableOutput.setSelectionRange(0, 99999); // For mobile devices
            document.execCommand('copy');
            copyableOutput.setSelectionRange(0, 0); // Clear selection
          }
          
          // Show feedback that copy was successful
          copyButton.textContent = "Copied!";
          copyButton.classList.add("copied");
          
          // Reset button after 2 seconds
          setTimeout(() => {
            copyButton.textContent = "Copy";
            copyButton.classList.remove("copied");
          }, 2000);
          
        } catch (err) {
          // Show error feedback
          copyButton.textContent = "Failed";
          setTimeout(() => {
            copyButton.textContent = "Copy";
          }, 2000);
        }
      });

      // Function to adjust brightness of color codes in text
      function adjustTextBrightness(text, factor) {
        // Match all color codes including ANSI (both actual escape chars and visible \033)
        return text.replace(/((?:\x1b|\u001b|\\033)\[(?:3[0-7]|9[0-7]|38;5;\d{1,3}|38;2;\d{1,3};\d{1,3};\d{1,3})m|\$X[0-9a-fA-F]{6}|\$x\d{3}|@x\d{3}|\{x\d{3}|\^\[[F]\d{3}\]|@\[[F]\d{3}\]|\\t\[[F]\d{3}\]|\&\d{3}|\{\d{3})/g, function(match) {
          let rgb;
          let newColorCode;
          
          if (match.startsWith("\x1b[") || match.startsWith("\u001b[") || match.startsWith("\\033[")) {
            // Handle ANSI codes
            if (match.match(/(?:\x1b|\u001b|\\033)\[3[0-7]m/)) {
              // Standard colors (30-37)
              const colorNum = parseInt(match.match(/[0-7]/)[0]);
              const newIdx = adjustXtermColor(colorNum, factor > 0);
              newColorCode = `\\033[3${newIdx}m`;
            } else if (match.match(/(?:\x1b|\u001b|\\033)\[9[0-7]m/)) {
              // Bright colors (90-97)
              const colorNum = parseInt(match.match(/[0-7]/)[0]) + 8;
              const newIdx = adjustXtermColor(colorNum, factor > 0);
              if (newIdx < 8) {
                newColorCode = `\\033[3${newIdx}m`;
              } else {
                newColorCode = `\\033[9${newIdx - 8}m`;
              }
            } else if (match.match(/(?:\x1b|\u001b|\\033)\[38;5;(\d+)m/)) {
              // 256 color
              const matches = match.match(/(?:\x1b|\u001b|\\033)\[38;5;(\d+)m/);
              const colorNum = parseInt(matches[1]);
              const newIdx = adjustXtermColor(colorNum, factor > 0);
              newColorCode = `\\033[38;5;${newIdx}m`;
            } else if (match.match(/(?:\x1b|\u001b|\\033)\[38;2;(\d+);(\d+);(\d+)m/)) {
              // True color
              const matches = match.match(/(?:\x1b|\u001b|\\033)\[38;2;(\d+);(\d+);(\d+)m/);
              rgb = {
                r: parseInt(matches[1]),
                g: parseInt(matches[2]),
                b: parseInt(matches[3])
              };
              const adjusted = adjustBrightness(rgb, factor, true);
              newColorCode = `\\033[38;2;${adjusted.r};${adjusted.g};${adjusted.b}m`;
            } else {
              return match; // Unknown ANSI format
            }
          } else if (match.startsWith("$X") && match.length === 8) {
            // Handle $X truecolor format
            const hex = match.slice(2);
            rgb = {
              r: parseInt(hex.slice(0, 2), 16),
              g: parseInt(hex.slice(2, 4), 16),
              b: parseInt(hex.slice(4, 6), 16)
            };
            const adjusted = adjustBrightness(rgb, factor, true); // Use precise adjustment for truecolor
            newColorCode = '$X' + toHex(adjusted.r) + toHex(adjusted.g) + toHex(adjusted.b);
          } else if ((match.startsWith("$x") || match.startsWith("@x") || match.startsWith("{x")) && match.length === 5) {
            // Handle xterm color codes using proper xterm adjustment
            const idx = parseInt(match.slice(2), 10);
            const newIdx = adjustXtermColor(idx, factor > 0);
            newColorCode = match.slice(0, 2) + String(newIdx).padStart(3, "0");
          } else if ((match.startsWith("@[F") && match.endsWith("]")) ||
                     (match.startsWith("\\t[F") && match.endsWith("]")) ||
                     (match.startsWith("^[F") && match.endsWith("]"))) {
            // Handle F-color codes - they represent 6x6x6 cube colors
            const inside = match.includes("\\t") ? match.slice(3, -1) : match.slice(2, -1);
            const r = parseInt(inside.charAt(1), 10);
            const g = parseInt(inside.charAt(2), 10);
            const b = parseInt(inside.charAt(3), 10);
            const colorIndex = 16 + 36 * r + 6 * g + b;
            
            // Use proper xterm adjustment
            const newIdx = adjustXtermColor(colorIndex, factor > 0);
            
            // Convert back to F-color format
            if (newIdx >= 16 && newIdx <= 231) {
              const base = newIdx - 16;
              const newR = Math.floor(base / 36) % 6;
              const newG = Math.floor(base / 6) % 6;
              const newB = base % 6;
              if (match.startsWith("\\t")) {
                newColorCode = `\\t[F${newR}${newG}${newB}]`;
              } else if (match.startsWith("^")) {
                newColorCode = `^[F${newR}${newG}${newB}]`;
              } else {
                newColorCode = `@[F${newR}${newG}${newB}]`;
              }
            } else {
              return match; // Can't convert, keep original
            }
          } else if ((match.startsWith("&") || match.startsWith("{")) && match.match(/^\D\d{3}$/)) {
            // Handle &NNN or {NNN format using proper xterm adjustment
            const idx = parseInt(match.slice(1), 10);
            const newIdx = adjustXtermColor(idx, factor > 0);
            newColorCode = match.charAt(0) + String(newIdx).padStart(3, "0");
          } else {
            return match; // Unknown format, keep original
          }
          
          return newColorCode;
        });
      }

      // Instant brightness adjustment event listeners
      document.getElementById("instantLighterButton").addEventListener("click", function() {
        const copyableOutput = document.getElementById("copyableOutput");
        const currentText = copyableOutput.value;
        
        if (!currentText) {
          alert("No colored text to adjust!");
          return;
        }
        
        // Adjust brightness of all color codes in the text (5% increments for finer control)
        const adjustedText = adjustTextBrightness(currentText, 5);
        
        // Debug: Check if anything changed
        if (adjustedText === currentText) {
          console.log("Warning: No color codes were adjusted. Input:", currentText);
        }
        
        // Update the copyable output
        copyableOutput.value = adjustedText;
        
        // Update the preview
        updateOutput(adjustedText);
      });

      document.getElementById("instantDarkerButton").addEventListener("click", function() {
        const copyableOutput = document.getElementById("copyableOutput");
        const currentText = copyableOutput.value;
        
        if (!currentText) {
          alert("No colored text to adjust!");
          return;
        }
        
        // Adjust brightness of all color codes in the text (5% increments for finer control)
        const adjustedText = adjustTextBrightness(currentText, -5);
        
        // Update the copyable output
        copyableOutput.value = adjustedText;
        
        // Update the preview
        updateOutput(adjustedText);
      });

      initialize();
    </script>
  </body>
</html>